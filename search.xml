<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 启动 Nginx</title>
    <url>/blog/2020/10/06/Docker%E5%90%AF%E5%8A%A8Nginx/</url>
    <content><![CDATA[<p>常规安装可以在官网上找到具体步骤,这里主要是记录 Docker 安装 Nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker 拉取 nginx 官方镜像</span></span><br><span class="line">docker pull nginx:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 nginx 容器并挂载目录映射90端口 (建议: 先启动一个容器把需要映射的文件拷贝出来,然后删除容器,重新启动一个容器把文件映射进去)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v 命令表示把外部文件挂载到容器内部,直接启动的话挂载的目录会没有文件!!!</span></span><br><span class="line">docker run -d --name nginx-container -p 90:80 \</span><br><span class="line">-v /data/nginx/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /data/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /data/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /data/nginx/log:/var/log/nginx \</span><br><span class="line">--restart=always \</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure>

<p>以上就是 docker 启动 nginx 的详细命令</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC 简介</title>
    <url>/blog/2020/12/20/JDBC%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>JDBC (Java Database Connectivity) 是 Java 1997年引入的一种自然的、易于使用的访问关系型数据库的接口。各大厂商也提供了 JDBC 驱动的实现。在 Java 应用中，JDBC 可以执行 SQL 语句、检索 SQL 执行结果、将数据改写到底层数据源。可用于分布式、异构的环境中与多个数据源进行交互。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用 JDBC 操作数据源大致需要以下几步：</p>
<ul>
<li>建立数据源连接</li>
<li>执行 SQL 语句</li>
<li>检索 SQL 执行结果</li>
<li>关闭连接</li>
</ul>
<h3 id="建立数据源连接"><a href="#建立数据源连接" class="headerlink" title="建立数据源连接"></a>建立数据源连接</h3><p>JDBC 中抽象了 Connection 接口，表示与底层数据源连接。JDBC 可通过以下两种方式获取 Connection 对象：</p>
<ul>
<li><code>DriverManager#getConnection()</code> (JDBC 1.0)</li>
<li><code>DataSource#getConnection()</code> (JDBC 2.0)</li>
</ul>
<p>值得一提的是，JDBC 并没有提供 DataSource 的实现，DataSource 的具体实现由数据库厂商提供。此外，一些主流的数据库连接池（如 C3P0、Druid等）也提供了 DataSource 的具体实现。</p>
<p>所有的 JDBC 驱动都必须实现 Driver 接口。而且实现类都包含一个静态初始化代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pulic <span class="class"><span class="keyword">class</span> <span class="title">CustomDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> CustomDirver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们加载启动类时，静态代码块就会调用，然后向 DriverManager 中注册一个驱动类的实例。所以我们使用 JDBC 操作数据库的时候一般会先加载驱动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了确保这种机制，Driver 实现类需提供一个无参构造器。</p>
<h3 id="执行-SQL-语句"><a href="#执行-SQL-语句" class="headerlink" title="执行 SQL 语句"></a>执行 SQL 语句</h3><p>获取到 Connection 对象后，我们就可以通过 Connection 对象设置事务的属性，并且通过 Connection 创建 Statement、PreparedStatement、CallableStatement对象。</p>
<ul>
<li><p>Statement</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Statement 即 JDBC 提供的 SQL 语句执行器。主要提供了以下几个方法:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询操作</span></span><br><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行更新操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行批量处理</span></span><br><span class="line"><span class="keyword">int</span>[] executeBatch() <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>PreparedStatement</p>
<p>PreparedStatement 也实现了 Statement 接口，表示预编译的 SQL 语句的对象，用于执行带参数的预编译的SQL语句。</p>
</li>
<li><p>CallableStatement</p>
<p>CallableStatement 则实现了 PrepareStatement 接口，提供了用来调用数据库中存储过程的 API，如果有输出参数要注册，说明是输出参数。</p>
</li>
</ul>
<h3 id="检索-SQL-执行结果"><a href="#检索-SQL-执行结果" class="headerlink" title="检索 SQL 执行结果"></a>检索 SQL 执行结果</h3><p>JDBC 提供了 ResultSet 接口，该接口的实现类封装了 SQL 查询的结果，我们可以对 ResultSet 对象进行遍历，然后获取对应结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;Select * From user&quot;</span>;</span><br><span class="line">ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">ResultSetMetaData metaData = resultSet.getMetaData();</span><br><span class="line"><span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">           String columnName = metaData.getColumnName(i);</span><br><span class="line">           String columnVal = resultSet.getString(columnName);</span><br><span class="line">           System.out.printf(<span class="string">&quot;%s:%s\n&quot;</span>, columnName, columnVal);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>不管是 Connection 接口 还是 Statement 接口，都实现了 AutoCloseable 接口。AutoCloseable 定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以调用 <code>Connection#close()</code> 方法显式关闭数据库连接。调用该方法后，由 Connection 对象创建的所有 Statement 对象都会被关闭。所以一旦 Connection 对象关闭后，调用其方法都会抛出 SQLException 异常。</p>
<p>例如 HSQLDB Conneciton 实现类 JDBCConnection：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Changed to synchronized above because</span></span><br><span class="line">        <span class="comment">// we would not want a sessionProxy.close()</span></span><br><span class="line">        <span class="comment">// operation to occur concurrently with a</span></span><br><span class="line">        <span class="comment">// statementXXX.executeXXX operation.</span></span><br><span class="line">        <span class="keyword">if</span> (isInternal || isClosed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isClosed       = <span class="keyword">true</span>;</span><br><span class="line">        rootWarning    = <span class="keyword">null</span>;</span><br><span class="line">        connProperties = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isPooled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (poolEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                poolEventListener.connectionClosed();</span><br><span class="line"></span><br><span class="line">                poolEventListener = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sessionProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sessionProxy.close();</span><br><span class="line"></span><br><span class="line">            sessionProxy = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        checkClosed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> props =</span><br><span class="line">            ResultProperties.getValueForJDBC(JDBCResultSet.TYPE_FORWARD_ONLY,</span><br><span class="line">                JDBCResultSet.CONCUR_READ_ONLY, rsHoldability);</span><br><span class="line">        Statement stmt = <span class="keyword">new</span> JDBCStatement(<span class="keyword">this</span>, props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkClosed</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isClosed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> JDBCUtil.connectionClosedException();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SQLException <span class="title">connectionClosedException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只跟踪到这里</span></span><br><span class="line">        <span class="keyword">return</span> sqlException(ErrorCode.X_08003);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isClosed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC 驱动注册</title>
    <url>/blog/2020/12/23/JDBC%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h2 id="java-sql-Driver-接口"><a href="#java-sql-Driver-接口" class="headerlink" title="java.sql.Driver 接口"></a>java.sql.Driver 接口</h2><p>所有的 JDBC 驱动都必须实现 Driver 接口，且实现类必须包含一个静态初始化代码块。驱动实现类须在静态初始化代码块中向 DriverManager 注册自己的一个实例。例如：</p>
<ul>
<li><p>MySQL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HSQLDB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> JDBCDriver driverInstance = <span class="keyword">new</span> JDBCDriver();</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDriver</span> <span class="keyword">implements</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#ifdef JAVA8</span></span><br><span class="line">            DriverManager.registerDriver(driverInstance, <span class="keyword">new</span> EmptyDiverAction());</span><br><span class="line"><span class="comment">//#else</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            DriverManager.registerDriver(driverInstance);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#endif JAVA8</span></span><br><span class="line"></span><br><span class="line">        	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li>
</ul>
<p>当我们加载驱动类的时候，静态初始化代码块便会调用。这就是为什么我们使用 JDBC 操作数据库的时候要先加载驱动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当然，为了确保这一机制，所有 JDBC 驱动实现类都必须提供一个无参构造器，例如 MySQL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java-sql-DriverManager"><a href="#java-sql-DriverManager" class="headerlink" title="java.sql.DriverManager"></a>java.sql.DriverManager</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>当 DriverManager 类开始初始化时，会调用 <code>DiverManager#loadInitialDrivers()</code> 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the initial JDBC drivers by checking the System property</span></span><br><span class="line"><span class="comment"> * jdbc.properties and then use the &#123;<span class="doctag">@code</span> ServiceLoader&#125; mechanism</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化所有 jdbc.drivers 指定驱动类</span></span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DiverManager#loadInitialDrivers()</code> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String drivers;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 jdbc.drivers 指定的值</span></span><br><span class="line">            drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            drivers = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过 SPI 机制加载驱动类， AccessController.doPrivileged 表示以特权方式执行</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 这里不会加载实现类，只会在调用的时候加载</span></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">// 在这里加载实现类 参考 ServiceLoader#LazyIterator#hasNextService() 方法</span></span><br><span class="line">                        <span class="comment">// ServiceLoader#LazyIterator#nextService() 方法</span></span><br><span class="line">                        driversIterator.next();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">        <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">                <span class="comment">// 加载 jdbc.drivers 所指定的驱动类</span></span><br><span class="line">                Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-SPI-机制"><a href="#Java-SPI-机制" class="headerlink" title="Java SPI 机制"></a>Java SPI 机制</h2><p>在 JDBC 4.0 以前，调用 <code>DriverManager#getConnection()</code> 方法获取 Connection 对象之前都需要通过代码显示加载驱动实现类，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>而 4.0 以后则不需要这一步骤。这得益于 Java 的 SPI 机制。</p>
<h3 id="SPI-简介"><a href="#SPI-简介" class="headerlink" title="SPI 简介"></a>SPI 简介</h3><blockquote>
<p>SPI (Service Provider Interface) 是 JDK 内置的一种服务提供发现机制。SPI 是一种动态替换发现的机制。当服务的提供者提供了一种接口的实现之后，需要在 classpath 下的 META-INF/services 目录中创建一个<strong>以服务接口命名</strong>的文件，这个文件中的内容就是这个接口具体的实现类。当其他的程序需要这个服务的时候，就可以查找这个JAR包中 META-INF/services 目录的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名加载服务实现类，然后就可以使用该服务了。</p>
</blockquote>
<h3 id="SPI-使用"><a href="#SPI-使用" class="headerlink" title="SPI 使用"></a>SPI 使用</h3><p>JDK 中查找服务实现的工具类是 <code>java.util.ServiceLoader</code> ，使用如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SPITest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; drivers = ServiceLoader.load(Driver.class);</span><br><span class="line">        <span class="keyword">for</span> (Driver driver : drivers) &#123;</span><br><span class="line">            System.out.println(driver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>ServiceLoader#load(Driver dirver)</code> 方法后会返回一个 ServiceLoader<T> 实例，以下是代码调用链：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    	ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    	<span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            ClassLoader loader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 调用其构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行初始化操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">        loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">        reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        providers.clear();</span><br><span class="line">    	<span class="comment">// 初始化内部 Iterator 实现类，当遍历迭代器的时候，才回去加载对应实现类</span></span><br><span class="line">        lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历迭代器，调用 next() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="comment">// 获取实现类名称，nextName 赋值在 hasNextService() 方法</span></span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载</span></span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                <span class="comment">// 加入缓存</span></span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line">  Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">  Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 终于等到正主了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 资源文件路径</span></span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="comment">// 获取资源文件路径</span></span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析文件，获取所有实现类</span></span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Iterator&lt;String&gt; <span class="title">parse</span><span class="params">(Class&lt;?&gt; service, URL u)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader r = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = u.openStream();</span><br><span class="line">            r = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) &gt;= <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error reading configuration file&quot;</span>, x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) r.close();</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException y) &#123;</span><br><span class="line">                fail(service, <span class="string">&quot;Error closing configuration file&quot;</span>, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names.iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parseLine</span><span class="params">(Class&lt;?&gt; service, URL u, BufferedReader r, <span class="keyword">int</span> lc,</span></span></span><br><span class="line"><span class="params"><span class="function">                          List&lt;String&gt; names)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String ln = r.readLine();</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ci = ln.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) ln = ln.substring(<span class="number">0</span>, ci);</span><br><span class="line">        ln = ln.trim();</span><br><span class="line">        <span class="keyword">int</span> n = ln.length();</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ln.indexOf(<span class="string">&#x27; &#x27;</span>) &gt;= <span class="number">0</span>) || (ln.indexOf(<span class="string">&#x27;\t&#x27;</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                fail(service, u, lc, <span class="string">&quot;Illegal configuration-file syntax&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> cp = ln.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isJavaIdentifierStart(cp))</span><br><span class="line">                fail(service, u, lc, <span class="string">&quot;Illegal provider-class name: &quot;</span> + ln);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) &#123;</span><br><span class="line">                cp = ln.codePointAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                    fail(service, u, lc, <span class="string">&quot;Illegal provider-class name: &quot;</span> + ln);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))</span><br><span class="line">                names.add(ln);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lc + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上源码分析，可见 SPI 实现还是比较复杂的。</p>
<h3 id="SPI-总结"><a href="#SPI-总结" class="headerlink" title="SPI 总结"></a>SPI 总结</h3><p>ServiceLoader类提供了一个静态的load()方法，用于加载指定接口的所有实现类。调用该方法后，classpath 下 META-INF/services 目录的以服务名命名的文件中指定的所有实现类都会被加载。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要符合 JDBC 4.0 以上版本的 JDBC 驱动都会在 META-INF/services 目录的 java.sql.Driver 文件中指定驱动实现类的完全限定名。然后 DriverManager 通过 Java SPI 机制会自动加载这些驱动实现类。</p>
]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 内存结构</title>
    <url>/blog/2021/02/23/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li><p>简介</p>
<p>在 Java 虚拟机中， **堆(Heap)<strong>是可供各线程共享的运行时内存区域， 该区域也几乎 Java 虚拟机所管理的最大内存区域， 该区域随着虚拟机启动而创建， <strong>所有类的实例和数组对象也几乎在这里进行分配</strong>。 这块区域管理的对象无需， 也无法显示地被销毁， <strong>自动内存管理系统(Automatic Storage Management System)</strong> 也就是常说的</strong>垃圾收集器(Garbage Collector)**会对此区域的对象进行管理。 Java 堆的容量可以是固定大小的， 也可以随着程序执行的需求动态扩展， 并在不需要过多空间时自动收缩。 <strong>Java 堆所使用的内存不需要保证是连续的</strong>。</p>
</li>
<li><p>异常</p>
<p><strong>如果实际所需的堆超过了自动管理内存系统所能够提供的最大容量， 那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</strong></p>
</li>
</ul>
<h2 id="方法区-永久代-元空间"><a href="#方法区-永久代-元空间" class="headerlink" title="方法区(永久代|元空间)"></a>方法区(永久代|元空间)</h2><ul>
<li><p>简介</p>
<p> HotSpot 虚拟机设计团队把收集器的分代设计扩展到了方法区(使用永久代来实现了方法区)， <strong>方法区时可供各线程共享的运行时内存区域</strong>。 它存储了每一个类的结构信息， 例如 <strong>运行时常量池(Runtime Constant Pool)<strong>， <strong>字段</strong>和</strong>方法数据</strong>， <strong>构造函数</strong>和<strong>普通方法的字节码内容</strong>， 还包括一些在<strong>类， 实例， 接口初始化时用到的特殊方法</strong>。</p>
<p>方法区在虚拟机启动的时候创建， 是堆的逻辑组成部分， 简单虚拟机可以选择在这个区域不实现垃圾收集。方法区的容量可以是固定大小的， 也可以是动态扩展和收缩的。 在实际内存空间中可以是不连续的。 </p>
</li>
<li><p>异常</p>
<p> <strong>参考堆异常</strong>。</p>
</li>
</ul>
<h3 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h3><p>运行时常量池是方法区的一部分， Class 文件中除了有类的版本， 字段， 方法， 接口等描述信息外， 还有一项信息是<strong>常量池表(Constant Pool Table)<strong>， 用于存放编译期生成的各种字面量与符号引用， 这部分内容将在类</strong>加载后存放到方法区的运行时常量池</strong>中。所以运行时常量池随着类和接口的加载被创建。<strong>异常收到方法区的限制， 创建运行时常量池的时候所需内存超过方法区所能提供的最大值， 那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常</strong>。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li><p>简介 </p>
<p>Java 虚拟机栈( Java Virtual Machine Stack) 是线程私有的， 它的生命周期和线程相同。</p>
<p>每个方法被执行时， Java 虚拟机会同步创建一个栈帧(Stack Frame) 用于存储<strong>局部变量表</strong>， <strong>操作数栈</strong>， <strong>动态连接</strong>， <strong>方法出口</strong>等信息。 每一个方法被调用直至执行完毕的过程， 就对应一个<strong>栈帧在虚拟机中从入栈到出栈的过程</strong>。</p>
</li>
<li><p>异常情况</p>
<p>在 <strong>Java 虚拟机规范</strong> 中， 对这个内存区域规定了两类异常情况：</p>
<ul>
<li>如果线程请求的栈**深度(容量)<strong>大于虚拟机所允许的</strong>深度(最大容量)**， Java虚拟机将抛出 <strong>StackOverflowError</strong> 异常。</li>
<li>如果Java虚拟机可以动态扩展， 当扩展时无法申请到足够的内存去完成扩展， 或者建立新的线程时没有足够的内存去创建对应的虚拟机栈， 那么Java虚拟机会抛出一个 <strong>OutOfMemoryError</strong>异常。</li>
</ul>
</li>
</ul>
<h2 id="本地方法栈-不一定要实现"><a href="#本地方法栈-不一定要实现" class="headerlink" title="本地方法栈(不一定要实现)"></a>本地方法栈(不一定要实现)</h2><ul>
<li><p>简介</p>
<p>Java 虚拟机实现可能会使用到传统的栈来支持 native 方法(<strong>指使用Java以外的其它语言编写的方法</strong>)的执行， 这个栈就是本地方法栈， 如果 Java 虚拟机不支持 native 方法， 并且也不依赖传统栈的话， 可以无需支持本地方法栈。 <strong>和虚拟机栈一样</strong>， 本地方法栈也是线程私有 ， 其作用与虚拟机方法栈时非常相似的， 其区别只是虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务， 而本地方法栈则为虚拟机使用到的本地(native)方法服务。</p>
</li>
<li><p>异常 </p>
<p><strong>参考虚拟机栈异常</strong>。</p>
</li>
</ul>
<h2 id="程序计数器-Program-Counter-寄存器"><a href="#程序计数器-Program-Counter-寄存器" class="headerlink" title="程序计数器(Program Counter 寄存器)"></a>程序计数器(Program Counter 寄存器)</h2><ul>
<li><p>简介</p>
<p>每一条 Java 虚拟机线程都有自己的 PC 寄存器， 在任意时刻， 一条 Java 虚拟机线程只会执行一个方法的代码， 这个正在被线程执行的方法称为该线程的<strong>当前方法(Current Method)<strong>。 如果这个方法不是 native 的， 那 PC 寄存器就保存 Java 虚拟机正在执行的</strong>字节码指令</strong>的地址， 如果该方法时 native 的， 那 PC 寄存器的值就是  <strong>undefined</strong>， PC 寄存器的容量至少应该能保存一个 <strong>returnAddress类型</strong>的数据或者一个与平台相关的本地指针的值。</p>
</li>
</ul>
<p><strong>虚拟机栈， 本地方法栈， 程序计数器为线程私有区域</strong>。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java null 比较问题</title>
    <url>/blog/2020/09/20/Java%20null%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>null 不能与数值进行比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// null 直接和数据比较， 编译报错</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">null</span> == <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值变量，然后再比较，会抛出 NullPointerException</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">Integer b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = a == b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原因： == 比较是直接比较内存地址大小，<code>Integer b = null</code>中 b 并未指向任何地址，所以程序会抛出 <code>NullPointerException</code> 。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 远程操作</title>
    <url>/blog/2020/12/08/Linux%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="远程登录-Linux"><a href="#远程登录-Linux" class="headerlink" title="远程登录 Linux"></a>远程登录 Linux</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式一：使用密码登录</span></span><br><span class="line">ssh user$ip</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二： 使用密钥文件实现免密登录</span></span><br><span class="line">ssh -i key_file user@ip</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh -o 参数解释 &amp; 这些参数也可以在服务器 /etc/ssh/sshd_config 文件中设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例：ssh -o StrictHostKeyChecking=no -i key_file user@ip :使用 StrictHostKeyChecking=no 可以不进行 known_hosts 验证，但这样会有被攻击风<span class="comment"># 险</span></span></span><br><span class="line">ConnectTimeout=3                   连接时超时时间，3秒</span><br><span class="line">ConnectionAttempts=5               连接失败后重试次数，5次</span><br><span class="line">PasswordAuthentication=no          是否使用密码认证，（在遇到没做信任关系时非常有用，不然会卡在那里）</span><br><span class="line">StrictHostKeyChecking=no           第一次登陆服务器时自动拉取key文件，（跟上面一样，并且在第一次ssh登陆时，自动应答yes）</span><br></pre></td></tr></table></figure>

<h2 id="远程复制文件"><a href="#远程复制文件" class="headerlink" title="远程复制文件"></a>远程复制文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基本使用： 从本地复制文件到 linux</span></span><br><span class="line">scp -i key_file local_file user@ip:remote_dir</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制目录： 使用参数 -r 表示递归复制目录</span></span><br><span class="line">scp -i key_file -r local_dir user@ip:remote_dir</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制目录： 使用参数 -rpC 表示递归复制目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p：保留原文件的修改时间，访问时间和访问权限。</span></span><br><span class="line">scp -i key_file -rpc local_dir user@ip:remote_dir</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> scp 也可以使用 -o 参数： 用法同 ssh</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 核心组件 Configuration</title>
    <url>/blog/2020/12/24/MyBatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6Configuration/</url>
    <content><![CDATA[<h2 id="Configuration-简介"><a href="#Configuration-简介" class="headerlink" title="Configuration 简介"></a>Configuration 简介</h2><p>MyBatis 框架的配置信息有两种类型，一种是 Mybatis 框架属性的主配置文件，另外一种则是大家耳熟能详的配置执行 SQL 语句的 Mapper 配置文件。而 Configuration 类的作用正是描述 MyBatis 的主配置文件信息。比如以下属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> safeRowBoundsEnabled;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> safeResultHandlerEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> mapUnderscoreToCamelCase;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> aggressiveLazyLoading;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> multipleResultSetsEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> useGeneratedKeys;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> useColumnLabel = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> cacheEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> callSettersOnNulls;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> useActualParamName = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> returnInstanceForEmptyRow;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> shrinkWhitespacesInSql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> String logPrefix;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;? extends Log&gt; logImpl;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;? extends VFS&gt; vfsImpl;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; defaultSqlProviderType;</span><br><span class="line"><span class="keyword">protected</span> LocalCacheScope localCacheScope = LocalCacheScope.SESSION;</span><br><span class="line"><span class="keyword">protected</span> JdbcType jdbcTypeForNull = JdbcType.OTHER;</span><br><span class="line"><span class="keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;toString&quot;</span>));</span><br><span class="line"><span class="keyword">protected</span> Integer defaultStatementTimeout;</span><br><span class="line"><span class="keyword">protected</span> Integer defaultFetchSize;</span><br><span class="line"><span class="keyword">protected</span> ResultSetType defaultResultSetType;</span><br><span class="line"><span class="keyword">protected</span> ExecutorType defaultExecutorType = ExecutorType.SIMPLE;</span><br><span class="line"><span class="keyword">protected</span> AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;</span><br><span class="line"><span class="keyword">protected</span> AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;</span><br><span class="line"><span class="keyword">protected</span> String databaseId;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; configurationFactory;</span><br></pre></td></tr></table></figure>

<p>以上属性值都可以在 MyBatis 主配置文件中通过 &lt;setting&gt; 标签指定, 例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关闭 Mapper 二级缓存 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启懒加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Configuration 类除了提供以上属性控制 MyBatis 行为外，还作为容器存放了以下信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">protected final MapperRegistry mapperRegistry = new MapperRegistry(this);</span><br><span class="line">protected final InterceptorChain interceptorChain = new InterceptorChain();</span><br><span class="line">protected final TypeHandlerRegistry typeHandlerRegistry = new TypeHandlerRegistry(this);</span><br><span class="line">protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();</span><br><span class="line">protected final LanguageDriverRegistry languageRegistry = new LanguageDriverRegistry();</span><br><span class="line"></span><br><span class="line">protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap<span class="tag">&lt;<span class="name">MappedStatement</span>&gt;</span>(&quot;Mapped Statements collection&quot;)</span><br><span class="line">    .conflictMessageProducer((savedValue, targetValue) -&gt;</span><br><span class="line">        &quot;. please check &quot; + savedValue.getResource() + &quot; and &quot; + targetValue.getResource());</span><br><span class="line">protected final Map&lt;String, Cache&gt; caches = new StrictMap<span class="tag">&lt;&gt;</span>(&quot;Caches collection&quot;);</span><br><span class="line">protected final Map&lt;String, ResultMap&gt; resultMaps = new StrictMap<span class="tag">&lt;&gt;</span>(&quot;Result Maps collection&quot;);</span><br><span class="line">protected final Map&lt;String, ParameterMap&gt; parameterMaps = new StrictMap<span class="tag">&lt;&gt;</span>(&quot;Parameter Maps collection&quot;);</span><br><span class="line">protected final Map&lt;String, KeyGenerator&gt; keyGenerators = new StrictMap<span class="tag">&lt;&gt;</span>(&quot;Key Generators collection&quot;);</span><br><span class="line"></span><br><span class="line">protected final Set<span class="tag">&lt;<span class="name">String</span>&gt;</span> loadedResources = new HashSet<span class="tag">&lt;&gt;</span>();</span><br><span class="line">protected final Map&lt;String, XNode&gt; sqlFragments = new StrictMap<span class="tag">&lt;&gt;</span>(&quot;XML fragments parsed from previous mappers&quot;);</span><br><span class="line"></span><br><span class="line">protected final Collection<span class="tag">&lt;<span class="name">XMLStatementBuilder</span>&gt;</span> incompleteStatements = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">protected final Collection<span class="tag">&lt;<span class="name">CacheRefResolver</span>&gt;</span> incompleteCacheRefs = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">protected final Collection<span class="tag">&lt;<span class="name">ResultMapResolver</span>&gt;</span> incompleteResultMaps = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">protected final Collection<span class="tag">&lt;<span class="name">MethodResolver</span>&gt;</span> incompleteMethods = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">    </span><br><span class="line">protected final Map&lt;String, String&gt; cacheRefMap = new HashMap<span class="tag">&lt;&gt;</span>();</span><br></pre></td></tr></table></figure>

<p>mapperRegistry：用于注册 Mapper 接口信息，建立 Mapper 接口的 Class 对象和 MapperProxyFactory 对象之间的关系，其中 MapperProxyFactory 对象用于创建 Mapper 动态代理对象。</p>
<p>interceptorChain：用于注册 MyBatis 插件信息，MyBatis 插件实际上就是一个拦截器。</p>
<p>typeHandlerRegistry：用于注册所有的 TypeHandler，并建立 JDBC 类型、JDBC类型与 TypeHandle r之间的对应关系。</p>
<p>typeAliasRegistry：用于注册所有的类型别名。</p>
<p>languageRegistry：用于注册 LanguageDriver，LanguageDriver 用于解析SQL配置，将配置信息转换为 SqlSource 对象。</p>
<p>mappedStatements：MappedStatemen t对象描述 &lt;insert|select|update|delete&gt; 等标签或者通过 @Select、@Delete、@Update、@Insert 等注解配置的SQL信息。MyBatis 将所有的 MappedStatement 对象注册到该属性中，其中 Key 为 Mapper 的 Id，Mapper 的 Id 则为 Mapper 命名空间+标签 Id, Value 为 MappedStatement 对象。</p>
<p>caches：用于注册 Mapper 中配置的所有缓存信息，其中 Key 为 Cache 的 Id，也就是 Mapper 的命名空间，Value 为 Cache 对象。</p>
<p>resultMaps：用于注册 Mapper 配置文件中通过 &lt;resultMap&gt; 标签配置的 ResultMap 信息，ResultMap 用于建立 Java 实体属性与数据库字段之间的映射关系，其中 Key 为 ResultMap 的 Id，该 Id 是由 Mapper 命名空间和 &lt;resultMap&gt; 标签的 id 属性组成的，Value 为解析 &lt;resultMap&gt; 标签后得到的 ResultMap 对象。</p>
<p>parameterMaps：用于注册 Mapper 中通过 &lt;parameterMap&gt; 标签注册的参数映射信息。Key 为 ParameterMap 的 Id，由 Mapper 命名空间和 &lt;parameterMap&gt; 标签的 id 属性构成，Value 为解析 &lt;parameterMap&gt; 标签后得到的ParameterMap对象。</p>
<p>keyGenerators：用于注册 KeyGenerator，KeyGenerator 是 MyBatis 的主键生成器，MyBatis 中提供了 3 种 KeyGenerator，即 Jdbc3KeyGenerator（数据库自增主键）、NoKeyGenerator（无自增主键）、SelectKeyGenerator（通过select语句查询自增主键，例如 oracle 的 sequence）。</p>
<p>loadedResources：用于注册所有Mapper XML配置文件路径。</p>
<p>sqlFragments：用于注册 Mapper 中通过 &lt;sql&gt; 标签配置的 SQL 片段，Key 为 SQL 片段的 Id，Value 为 MyBatis 封装的表示 XML 节点的 XNode 对象。</p>
<p>incompleteStatements：用于注册解析出现异常的 XMLStatementBuilder 对象。</p>
<p>incompleteCacheRefs：用于注册解析出现异常的 CacheRefResolver 对象。</p>
<p>incompleteResultMaps：用于注册解析出现异常的 ResultMapResolver 对象。</p>
<p>incompleteMethods：用于注册解析出现异常的 MethodResolver 对象。MyBatis 框架启动时，会对所有的配置信息进行解析，然后将解析后的内容注册到Configuration 对象的这些属性中。</p>
<p>除此之外，Configuration 还作为 MetaObject、Excetor、StatementHandler、ResultHandler、ParameterHandler 组件的工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MetaObject <span class="title">newMetaObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(object, objectFactory, objectWrapperFactory, reflectorFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">      ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newExecutor(transaction, defaultExecutorType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些工厂类主要是根据 MyBatis 的配置创建对应的实现类。其次 MyBatis 采用工厂模式创建 Executor、StatementHandler、ResultSetHandler、ParameterHandler 的另一个目的是实现插件拦截逻辑。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 核心组件 Executor</title>
    <url>/blog/2020/12/25/MyBatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6Executor/</url>
    <content><![CDATA[<h2 id="Executor-简介"><a href="#Executor-简介" class="headerlink" title="Executor 简介"></a>Executor 简介</h2><p>SqlSession 是我们最常用的，也是 MyBatis 提供的用于操作数据库的 API，但是真正执行 SQL 的确是 Executor 组件。Executor 中定义了对数据库 CRUD 的方法，如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ResultHandler NO_RESULT_HANDLER = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Transaction <span class="title">getTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setExecutorWrapper</span><span class="params">(Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 接口有几种不同实现类，如下图所示：</p>
<p><img src="/blog/img/Executor%E6%8E%A5%E5%8F%A3.png"></p>
<ul>
<li><p>BaseExecutor</p>
<blockquote>
<p>BaseExecutor 定义了方法的执行流程和通用的处理逻辑，而具体的方法由子类实现。是典型的模板方法模式的应用。</p>
</blockquote>
</li>
<li><p>SimpleExecutor</p>
<blockquote>
<p>SimpleExecutor 是基础的 Executor，能够完成基本的 CRUD 操作。</p>
</blockquote>
</li>
<li><p>ReuseExecutor</p>
<blockquote>
<p>ResueExecutor 运用了享元思想，对 JDBC 中的 Statement 对象做了缓存，当执行相同的 SQL 语句时，直接从缓存中取出 Statement 对象进行复用，避免了频繁创建和销毁 Statement 对象，从而提升系统性能。</p>
</blockquote>
</li>
<li><p>BatchExecutor</p>
<blockquote>
<p>BatchExecutor 会对调用同一个 Mapper 执行的 update、insert 和 delete 操作，调用 Statement 对象的批量操作功能。</p>
</blockquote>
</li>
<li><p>CachingExecutor</p>
<blockquote>
<p>MyBatis 支持一级缓存和二级缓存，当 MyBatis 开启二级缓存功能时，会使用 CachingExecutor 对 SimpleExecutor、ReuseExecutor、BatchExecutor  进行装饰，为查询操作增加二级缓存功能，这是装饰器模式的应用。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 简介</title>
    <url>/blog/2020/12/24/MyBatis%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>MyBatis 源于 Aapche 的一个开源项目 iBatis。而 iBatis 是 2002 年 Clinton Begin 开发的一款在持久层使用的半自动 ORM 框架。MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>消除了大量的 JDBC 冗余代码，包括参数设置、结果集封装等。</li>
<li>SQL 语句可控制，方便查询优化，使用更加灵活。</li>
<li>学习成本比较低，对于新用户能够快速学习使用。</li>
<li>提供了与主流 IOC 框架 Spring 的集成支持。</li>
<li>引入缓存机制，提供了与第三方缓存类库的集成支持。</li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 遍历当前文件夹</title>
    <url>/blog/2020/12/12/Shell%20for%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>shell for 指令一般使用的格式为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do </span><br><span class="line">	command1</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以写成一行</span></span><br><span class="line">for var in item1 item2 ... itemN;do comand1 done;</span><br></pre></td></tr></table></figure>



<p>for 遍历当前文件夹并给每个文件夹里创建一个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for file in ./*</span><br><span class="line">do</span><br><span class="line">	if test -d file</span><br><span class="line">	then </span><br><span class="line">		cd $file</span><br><span class="line">		touch file.txt</span><br><span class="line">		cd ..</span><br><span class="line">	fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 创建 starter</title>
    <url>/blog/2021/03/21/Spring%20Boot%E5%88%9B%E5%BB%BAstarter/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot 之所以能够流行，Spring starter 模式功不可没。Spring starter 的出现，可以让模块的开发更加独立化，更方便集成到应用中。比如像创建一个 web 项目，直接创建 Spring Boot 项目，然后引入以下依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="创建自定义-starter"><a href="#创建自定义-starter" class="headerlink" title="创建自定义 starter"></a>创建自定义 starter</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建一个简单的 Maven 项目。然后引入相关依赖，pom 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">		 xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">		 xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">	&lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;version&gt;<span class="number">2.5</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-demo&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;maven.compiler.source&gt;<span class="number">8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">		&lt;maven.compiler.target&gt;<span class="number">8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<h3 id="创建业务逻辑"><a href="#创建业务逻辑" class="headerlink" title="创建业务逻辑"></a>创建业务逻辑</h3><ul>
<li><p>创建一个 HelloService 接口，接口定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">Hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个 HelloService 接口实现类 HelloServiceImpl 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="添加自动配置项"><a href="#添加自动配置项" class="headerlink" title="添加自动配置项"></a>添加自动配置项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.example&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明配置文件路径"><a href="#声明配置文件路径" class="headerlink" title="声明配置文件路径"></a>声明配置文件路径</h3><p>在 Maven 项目的根路径下建立 META-INF/spring.factories 文件，并在文件中声明配置文件路径:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration = \</span><br><span class="line">com.example.config.HelloServiceAutoConfiguration    </span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>到此为止，一个标准的 starter 就开发完成了，我们可以新建一个 Spring Boot 项目，然后引入以下依赖即可使用 HelloService 提供的功能：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        String helloMsg = helloService.hello(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;helloMsg = &quot;</span> + helloMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue data 属性赋值后页面不刷新问题</title>
    <url>/blog/2021/03/12/Vue%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于 javascript 的限制, Vue 不能检测对象和数组的变化.</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li><p>对象</p>
<p>Vue无法检测对象 property 的添加或移除。由于 Vue会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种 Vue 页面是不会动态刷新的, 参考 https://cn.Vuejs.org/v2/guide/reactivity.html</span></span><br><span class="line">vm.obj.field = value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方式, 此种方式可进行响应式渲染</span></span><br><span class="line"><span class="built_in">this</span>.$set(vm.obj, <span class="string">&#x27;field&#x27;</span>, value)</span><br><span class="line"></span><br><span class="line">vm.obj = <span class="built_in">Object</span>.assign(&#123;&#125;, vm.obj, &#123; value &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于数组</p>
<p>当你利用索引直接设置一个数组项或者修改数组长度时, Vue 不能检测到数组的变动</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上, 这种更改数组 Vue 页面是不会进行动态刷新的</span></span><br><span class="line">vm.arr.indexOfArr = value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种方式可进行动态刷新 </span></span><br><span class="line"><span class="built_in">this</span>.$set(vm.arr, indexOfArr, value)</span><br><span class="line"></span><br><span class="line">vm.arr.splice(indexOfArr, <span class="number">1</span>, value)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 Vue 页面不动态刷新的问题可以参数 Vue 官方文档#<a href="https://cn.vuejs.org/v2/guide/reactivity.html">深入响应式原理相关内容</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>基本类型的 Class 实例</title>
    <url>/blog/2020/12/25/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84Class%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>今天再看 MyBatis 工具类 SqlRunner 源码的时候发现其构造器创建了一个 TypeHandlerRegistry 实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlRunner</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = <span class="keyword">new</span> TypeHandlerRegistry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是点进 TypeHandlerRegistry 类中进入瞄了一眼：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TypeHandlerRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用有参构造器</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Configuration());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TypeHandlerRegistry</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.unknownTypeHandler = <span class="keyword">new</span> UnknownTypeHandler(configuration);</span><br><span class="line"></span><br><span class="line">    register(Boolean.class, <span class="keyword">new</span> BooleanTypeHandler());</span><br><span class="line">    register(<span class="keyword">boolean</span>.class, <span class="keyword">new</span> BooleanTypeHandler());</span><br><span class="line">    register(JdbcType.BOOLEAN, <span class="keyword">new</span> BooleanTypeHandler());</span><br><span class="line">    register(JdbcType.BIT, <span class="keyword">new</span> BooleanTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Byte.class, <span class="keyword">new</span> ByteTypeHandler());</span><br><span class="line">    register(<span class="keyword">byte</span>.class, <span class="keyword">new</span> ByteTypeHandler());</span><br><span class="line">    register(JdbcType.TINYINT, <span class="keyword">new</span> ByteTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Short.class, <span class="keyword">new</span> ShortTypeHandler());</span><br><span class="line">    register(<span class="keyword">short</span>.class, <span class="keyword">new</span> ShortTypeHandler());</span><br><span class="line">    register(JdbcType.SMALLINT, <span class="keyword">new</span> ShortTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Integer.class, <span class="keyword">new</span> IntegerTypeHandler());</span><br><span class="line">    register(<span class="keyword">int</span>.class, <span class="keyword">new</span> IntegerTypeHandler());</span><br><span class="line">    register(JdbcType.INTEGER, <span class="keyword">new</span> IntegerTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Long.class, <span class="keyword">new</span> LongTypeHandler());</span><br><span class="line">    register(<span class="keyword">long</span>.class, <span class="keyword">new</span> LongTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Float.class, <span class="keyword">new</span> FloatTypeHandler());</span><br><span class="line">    register(<span class="keyword">float</span>.class, <span class="keyword">new</span> FloatTypeHandler());</span><br><span class="line">    register(JdbcType.FLOAT, <span class="keyword">new</span> FloatTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Double.class, <span class="keyword">new</span> DoubleTypeHandler());</span><br><span class="line">    register(<span class="keyword">double</span>.class, <span class="keyword">new</span> DoubleTypeHandler());</span><br><span class="line">    register(JdbcType.DOUBLE, <span class="keyword">new</span> DoubleTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Reader.class, <span class="keyword">new</span> ClobReaderTypeHandler());</span><br><span class="line">    register(String.class, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">    register(String.class, JdbcType.CHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">    register(String.class, JdbcType.CLOB, <span class="keyword">new</span> ClobTypeHandler());</span><br><span class="line">    register(String.class, JdbcType.VARCHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">    register(String.class, JdbcType.LONGVARCHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">    register(String.class, JdbcType.NVARCHAR, <span class="keyword">new</span> NStringTypeHandler());</span><br><span class="line">    register(String.class, JdbcType.NCHAR, <span class="keyword">new</span> NStringTypeHandler());</span><br><span class="line">    register(String.class, JdbcType.NCLOB, <span class="keyword">new</span> NClobTypeHandler());</span><br><span class="line">    register(JdbcType.CHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">    register(JdbcType.VARCHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">    register(JdbcType.CLOB, <span class="keyword">new</span> ClobTypeHandler());</span><br><span class="line">    register(JdbcType.LONGVARCHAR, <span class="keyword">new</span> StringTypeHandler());</span><br><span class="line">    register(JdbcType.NVARCHAR, <span class="keyword">new</span> NStringTypeHandler());</span><br><span class="line">    register(JdbcType.NCHAR, <span class="keyword">new</span> NStringTypeHandler());</span><br><span class="line">    register(JdbcType.NCLOB, <span class="keyword">new</span> NClobTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Object.class, JdbcType.ARRAY, <span class="keyword">new</span> ArrayTypeHandler());</span><br><span class="line">    register(JdbcType.ARRAY, <span class="keyword">new</span> ArrayTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(BigInteger.class, <span class="keyword">new</span> BigIntegerTypeHandler());</span><br><span class="line">    register(JdbcType.BIGINT, <span class="keyword">new</span> LongTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(BigDecimal.class, <span class="keyword">new</span> BigDecimalTypeHandler());</span><br><span class="line">    register(JdbcType.REAL, <span class="keyword">new</span> BigDecimalTypeHandler());</span><br><span class="line">    register(JdbcType.DECIMAL, <span class="keyword">new</span> BigDecimalTypeHandler());</span><br><span class="line">    register(JdbcType.NUMERIC, <span class="keyword">new</span> BigDecimalTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(InputStream.class, <span class="keyword">new</span> BlobInputStreamTypeHandler());</span><br><span class="line">    register(Byte[].class, <span class="keyword">new</span> ByteObjectArrayTypeHandler());</span><br><span class="line">    register(Byte[].class, JdbcType.BLOB, <span class="keyword">new</span> BlobByteObjectArrayTypeHandler());</span><br><span class="line">    register(Byte[].class, JdbcType.LONGVARBINARY, <span class="keyword">new</span> BlobByteObjectArrayTypeHandler());</span><br><span class="line">    register(<span class="keyword">byte</span>[].class, <span class="keyword">new</span> ByteArrayTypeHandler());</span><br><span class="line">    register(<span class="keyword">byte</span>[].class, JdbcType.BLOB, <span class="keyword">new</span> BlobTypeHandler());</span><br><span class="line">    register(<span class="keyword">byte</span>[].class, JdbcType.LONGVARBINARY, <span class="keyword">new</span> BlobTypeHandler());</span><br><span class="line">    register(JdbcType.LONGVARBINARY, <span class="keyword">new</span> BlobTypeHandler());</span><br><span class="line">    register(JdbcType.BLOB, <span class="keyword">new</span> BlobTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Object.class, unknownTypeHandler);</span><br><span class="line">    register(Object.class, JdbcType.OTHER, unknownTypeHandler);</span><br><span class="line">    register(JdbcType.OTHER, unknownTypeHandler);</span><br><span class="line"></span><br><span class="line">    register(Date.class, <span class="keyword">new</span> DateTypeHandler());</span><br><span class="line">    register(Date.class, JdbcType.DATE, <span class="keyword">new</span> DateOnlyTypeHandler());</span><br><span class="line">    register(Date.class, JdbcType.TIME, <span class="keyword">new</span> TimeOnlyTypeHandler());</span><br><span class="line">    register(JdbcType.TIMESTAMP, <span class="keyword">new</span> DateTypeHandler());</span><br><span class="line">    register(JdbcType.DATE, <span class="keyword">new</span> DateOnlyTypeHandler());</span><br><span class="line">    register(JdbcType.TIME, <span class="keyword">new</span> TimeOnlyTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(java.sql.Date.class, <span class="keyword">new</span> SqlDateTypeHandler());</span><br><span class="line">    register(java.sql.Time.class, <span class="keyword">new</span> SqlTimeTypeHandler());</span><br><span class="line">    register(java.sql.Timestamp.class, <span class="keyword">new</span> SqlTimestampTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(String.class, JdbcType.SQLXML, <span class="keyword">new</span> SqlxmlTypeHandler());</span><br><span class="line"></span><br><span class="line">    register(Instant.class, <span class="keyword">new</span> InstantTypeHandler());</span><br><span class="line">    register(LocalDateTime.class, <span class="keyword">new</span> LocalDateTimeTypeHandler());</span><br><span class="line">    register(LocalDate.class, <span class="keyword">new</span> LocalDateTypeHandler());</span><br><span class="line">    register(LocalTime.class, <span class="keyword">new</span> LocalTimeTypeHandler());</span><br><span class="line">    register(OffsetDateTime.class, <span class="keyword">new</span> OffsetDateTimeTypeHandler());</span><br><span class="line">    register(OffsetTime.class, <span class="keyword">new</span> OffsetTimeTypeHandler());</span><br><span class="line">    register(ZonedDateTime.class, <span class="keyword">new</span> ZonedDateTimeTypeHandler());</span><br><span class="line">    register(Month.class, <span class="keyword">new</span> MonthTypeHandler());</span><br><span class="line">    register(Year.class, <span class="keyword">new</span> YearTypeHandler());</span><br><span class="line">    register(YearMonth.class, <span class="keyword">new</span> YearMonthTypeHandler());</span><br><span class="line">    register(JapaneseDate.class, <span class="keyword">new</span> JapaneseDateTypeHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// issue #273</span></span><br><span class="line">    register(Character.class, <span class="keyword">new</span> CharacterTypeHandler());</span><br><span class="line">    register(<span class="keyword">char</span>.class, <span class="keyword">new</span> CharacterTypeHandler());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>发现该类在创建实例的时候注册了许多类型及其对应的 TypeHandler，但看到 boolean.class、int.class 的时候有点懵了，猜测是基本类型的 Class 的实例，但是也不太确定，毕竟以前也没遇到过。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>后面查了查资料，发现还真是基本类型的实例。我们知道包装类型 Class 实例可以通过以下几种方式获取，以 Integer 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 直接 类名.class 获取</span></span><br><span class="line">Class&lt;Integer&gt; clz1 = Inetger.class</span><br><span class="line"><span class="comment">// 2. 对象.getClass() 方法获取</span></span><br><span class="line">Integer num =  <span class="number">127</span>;</span><br><span class="line">Class&lt;? extends Integer&gt; clz2 = num.getClass();</span><br><span class="line"><span class="comment">// 3. Class.forName(className) 获取</span></span><br><span class="line">Class&lt;?&gt; clz3 = Class.forName(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是基本类型的 Class 对象怎么获取呢？没错，以 int 为例即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Integer&gt; clz1 = <span class="keyword">int</span>.class</span><br><span class="line">Class&lt;Integer&gt; clz2 = Inetger.class</span><br><span class="line">Class&lt;Integer&gt; clz3 = Integer.TYPE;</span><br><span class="line">System.out.println(clz1 == clz2)  <span class="comment">// false </span></span><br><span class="line">System.out.println(clz1 == clz3)  <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<p>通过以上示例，说明 int.class 与 Integer.Type 为同一份实列。我们来看一下 Integer.Type 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">&quot;int&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Return the Virtual Machine&#x27;s Class object for the named</span></span><br><span class="line"><span class="comment">   * primitive type.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Class#getPrimitiveClass</code>使用 native 修饰，即底层使用 C 实现，直接由 JVM 返回。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本类型的实例可以通过 <code>类型.class</code> 或者 <code>包装类型.Type</code> 获取。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>存储设备划分</title>
    <url>/blog/2020/10/04/%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h2 id="存储设备的层次"><a href="#存储设备的层次" class="headerlink" title="存储设备的层次"></a>存储设备的层次</h2><p>各种不同的存储分类如下图所示。 层次越高， 价格越贵， 速度越快。 从高到低， 每个层次价格会降低，速度变慢， 访问时间增加。 其中上面四层（<strong>寄存器、高速缓存、内存、固态硬盘</strong>）通常由半导体内存构成。</p>
<p><img src="/blog/img/%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="存储设备层次"></p>
<h2 id="存储系统划分"><a href="#存储系统划分" class="headerlink" title="存储系统划分"></a>存储系统划分</h2><p>存储系统可分为易失存储和非易失存储。当电源切断时， <strong>易失存储</strong>会丢失内容。所以为了安全着想一般数据都应该写到<strong>非易失存储</strong>。</p>
<p>在图 1-4 中， 固态磁盘之上的存储系统都是易失的， 而之下时非易失的， 固态磁盘时非易失的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完整的存储系统设计应该考虑多方面的因素：它应该只使用必须的昂贵存储， 而提供尽可能便宜的、非易失的存储。当两个存储组件的访问时间或传输速率具有明显差异时。可以通过高速缓存来改善性能。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库Null返回前端变为 -1 问题</title>
    <url>/blog/2021/03/18/%E6%95%B0%E6%8D%AE%E5%BA%93Null%E8%BF%94%E5%9B%9E%E5%89%8D%E7%AB%AF%E5%8F%98%E4%B8%BA%20-1%20%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在实体类上加上这个注解，使用 ToStringSerializer 序列化器</span></span><br><span class="line"><span class="meta">@JsonSerialize(using = ToStringSerializer.class)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 类加载过程</title>
    <url>/blog/2021/03/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>类加载过程分为7个阶段。加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析统称为连接</strong>。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载是整个类加载过程中的第一个阶段。在加载阶段， Java虚拟机需要完成以下三件事情：</p>
<ul>
<li><p>通过一个类的全限定名类获取此类的二进制字节流（不限制来源，开发人员可控性最强）。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区对这个类各种数据的访问入口</p>
</li>
</ul>
<p>《Java虚拟机规范》对这三点要求不是特别具体，留给虚拟机的灵活实现特别大。值得注意的一点是：数组类不通过类加载器创建，它是由 Java 虚拟机直接在内存中动态构造出来的。而加载阶段和连接阶段（验证、准备、解析）可能是交叉进行的。但开始时间任然保持着固定的先后顺序。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，目的是确保 Class 文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求。确保代码运行时不会危害虚拟机自身的安全。所以验证字节码是 Java 虚拟机保护自身的一项必要措施。这一阶段的工作量在虚拟机的类加载过程中占了相当大的比重。整体上看，验证分为四个阶段的检验动作：</p>
<ul>
<li><p><strong>文件格式验证</strong></p>
</li>
<li><p><strong>元数据验证</strong></p>
</li>
<li><p><strong>字节码验证</strong></p>
<p>此阶段最复杂，需通过数据流和控制流分析，确保程序语义是合法的，符合逻辑的。</p>
</li>
<li><p><strong>符号引用验证</strong></p>
</li>
</ul>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类中定义的变量(即静态变量)分配内存并设置类变量初始值的阶段。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value =  <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>其中变量 value 在准备结果过后的初始值为 0 而不是 123，因为这时尚未开始执行任何 Java 方法，而 value 赋值为 123 的 putstatic 指令时程序被编译后，存放在类构造器 &lt;clinit&gt;() 方法之中，所以把 value 赋值为 123 的动作要到类的初始化阶段才会被执行。</p>
<p>如果类字段的字段属性表中存在 ConstantValue 属性，那么准备阶段变量值就会被初始化为 ConstantValue 属性所指定的值，例子中 num 就会被虚拟机赋值为 123。</p>
<p><strong>注意</strong>：在准备阶段，虚拟机只会为类变量进行内存分配，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li><p>符号引用：</p>
<p>符号引用是以一组符号来描述所引用的目标，符号可以是任意的字面量，只要能够无歧义的定位到目标即可。符号引用的字面量形式明确定义在 《Java虚拟机规范》的 Class 文件格式中。所以与虚拟机实现的内存布局无关。<strong>符号引用并不一定是已经加载到虚拟机内存当中的内容</strong>。</p>
</li>
<li><p>直接引用：</p>
<p>直接引用就是可以直接执行目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实力上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那么引用的目标必定已经在虚拟机的内存中存在</strong>。</p>
</li>
</ul>
<p>《Java虚拟机规范》并未规定解析阶段发生的具体时间。只要求了在执行 newarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc_w、ldc2_w、multianewarray、new、putfield、putstatic 这17个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。</p>
<p>对同一个符号引用进行多次解析请求是很常见的，所以除了 invokedynamic 指令以外，虚拟机实现可以对第一次解析的结果进行缓存。</p>
<p><strong>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行</strong>。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类的初始化阶段是类加载过程中最后一个阶段。直到初始化阶段，Java 虚拟机才真正开始执行类中 Java 程序代码, 将主导权移交给应用程序。</p>
<p><strong>初始化阶段就是执行类构造器 <code>&lt;clinit&gt;() </code>方法的过程, <code>&lt;clinit&gt;()</code>并不是程序员在 Java 代码中编写的方法，它是 Javac 编译器的自动生成物。</strong></p>
<p><code>&lt;clinit&gt;()</code>方法：</p>
<ul>
<li><p>是由编译器自动收集类中所有类变量的赋值动态和静态语句块中的语句合并产生的，收集顺序由语句在源文件中出现的顺序决定，静态语句块中只能访问定义在静态语句块之前的变量，定义在之后的变量，前面的静态语句块可以赋值，但是不能访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i  = <span class="number">0</span>;  <span class="comment">// 给变量赋值可以正常编译通过 </span></span><br><span class="line">        System.out.print(i); <span class="comment">// 编译报错，提示 “非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>与类的构造函数（虚拟机中实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显示调用父类构造器，Java 虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在 Java 虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是 <code>java.lang.Object</code>。</p>
</li>
<li><p>对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化赋值操作，所以接口也会生成<code>&lt;clinit&gt;()</code>方法。但接口和类不同，接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>Java 虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其它线程都需要阻塞等待，直到活动线程执行完毕<code>&lt;clinit&gt;()</code>方法。如果在一个类的<code>&lt;clinit&gt;()</code>方法方法中有耗时很长的操作，那就可能造成多个进程阻塞。这种阻塞往往是很隐蔽的。当其中一个线程执行完<code>&lt;clinit&gt;()</code>方法后，其它线程唤醒后不会再次进入<code>&lt;clinit&gt;()</code>方法。<strong>在同一个类加载器下，一个类型只会被初始化一次</strong>。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>略。</p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>略。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 六种类初始化条件</title>
    <url>/blog/2021/02/24/%E7%B1%BB%E7%AB%8B%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<p>《Java虚拟机规范》严格规定了有且只有六种情况必须对类进行 “初始化”（加载、验证、准备需在此之前开始）。</p>
<ol>
<li><p>遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时。生成这四条指令的 Java 场景有：</p>
<blockquote>
<ul>
<li>使用 new 关键字实例化对象的时候</li>
<li>读取或设置一个静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
</blockquote>
</li>
<li><p>使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则会触发其初始化</p>
</li>
<li><p>初始化类时，发现其父类还未初始化，则需要先对其父类进行初始化</p>
</li>
<li><p>虚拟机启动时，用户需指定一个执行的主类（包含 main() 方法），虚拟机会先初始化这个类</p>
</li>
<li><p>如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、 REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需先触发其初始化</p>
</li>
<li><p>当一个接口定义了默认方法（被 default 关键字修饰的方法）时，如果有这个接口的实现类发生了初始化，那么该接口会在其之前被初始化</p>
</li>
</ol>
<p><strong>《Java虚拟机规范》中使用了一个非常强烈的限定语有且只有，这六种场景中的行为称为对一个类型的主动引用。除此之外，所有引用类型的方式都不会触发其初始化，称为被动引用。</strong></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中线程创建的几种方式</title>
    <url>/blog/2020/10/05/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><code>Java</code> 中线程的创建一般包含4种方式：</p>
<h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 <code>Thread</code> 类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Mythread 实例, 调用 start 方法启用一个新线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Mythread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 <code>Runnable</code> 接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pubic <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Thread 实例,传入 MyRunnable 实列, 调用 start 方法启用一个新线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 <code>Callable</code> 接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sting <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Callable callable = <span class="keyword">new</span> MyCallable;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        <span class="comment">// 创建一个 Thread 实例, 启用一个新线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// Future#get 方法会阻塞,一直等到线程运行完成, 会得到一个返回值</span></span><br><span class="line">        <span class="comment">// str = &#x27;hello world&#x27;</span></span><br><span class="line">        String str = futureTask.get();</span><br><span class="line">        <span class="comment">// 获取结果, 如果没结果可用, 则阻塞到指定时间为止,到时还未产生结果则抛出 TimeOutException 异常</span></span><br><span class="line">        String str1 = futureTask.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用线程池创建-推荐"><a href="#使用线程池创建-推荐" class="headerlink" title="使用线程池创建(推荐)"></a>使用线程池创建(推荐)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认参数：</span></span><br><span class="line"><span class="comment">     * 1） corePoolSize： 核心线程数</span></span><br><span class="line"><span class="comment">     * 2） maximumPoolSize: 最大线程数  0x7fffffff</span></span><br><span class="line"><span class="comment">     * 3)  keepAliveTime: 60L 存活时间</span></span><br><span class="line"><span class="comment">     * 4） unit： TimeUnit.SECONDS， 线程空闲大于指定存活时间， 就会释放线程</span></span><br><span class="line"><span class="comment">     * 5)  workQueue:  new SynchronousQueue&lt;Runnable&gt;() 阻塞队列</span></span><br><span class="line"><span class="comment">     * 6) threadFactory： 线程的创建工厂</span></span><br><span class="line"><span class="comment">     * 7） RejectedExecutionHandler : 如果队列满了，按照指定拒绝策略拒绝执行任务</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 工作顺序:</span></span><br><span class="line"><span class="comment">     * 1. 线程池创建， 准备好 core 线程数量的核心线程，准备接受任务</span></span><br><span class="line"><span class="comment">     * 2. core 满了， 就将再进来的任务放入到阻塞队列中，空闲的 core 就会自己去阻塞队列获取任务执行</span></span><br><span class="line"><span class="comment">     * 3. 阻塞队列满了， 就直接新开线程执行， 最大只能开到 max 指定的数量</span></span><br><span class="line"><span class="comment">     * 4. max 满了就要用 RejectedExecutionHandler 策略拒绝任务</span></span><br><span class="line"><span class="comment">     * 5. max 都执行完， 有很多空闲， 指定的时间 keepAliveTime 以后， 就会释放 max-core 这些线程</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 问题： 一个线程池 core 7、max 20、 queue 50， 100 并发进来是怎么分配的？</span></span><br><span class="line"><span class="comment">     * 答： 7个线程会获得立即执行， 50 个请求会进入到阻塞队列，队列满了会再开 13 个线程进行执行，剩下的就使用拒绝策略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TheadPoolExecutor executor = <span class="keyword">new</span> ThreadExecutor(<span class="number">5</span>, <span class="number">20</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">256</span>), 		       Excutors.DefaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前三种创建线程的方式其实都是一种, 即新建一个 <code>Thread</code> 实例, 调用  <code>start</code> 方法来创建一个线程, 这种方式也就是显示创建线程. 一般开发中不推荐这种方式, 开发中常用的是创建线程池的方式, 以线程池的方式创建线程有一下几个好处:</p>
<ol>
<li><p>降低资源消耗： 通过重复利用已经创建好的线程降低线程的创建和销毁带来的损耗</p>
</li>
<li><p>提高响应速度： 当线程池中的线程数没超过线程池的最大上限时，会有线程等待分配任务， 当任务来时无需创建新的线程就能运行</p>
</li>
<li><p>提高线程的可管理性： 线程池会优化处理，减少创建销毁线程带来的影响， 无限创建销毁线程会大量损耗系统资源， 降低系统稳定行，使用线程池可统一分配， 线程池不用的时候可以关闭</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 类加载器</title>
    <url>/blog/2021/03/02/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;Java 虚拟机设计团队有意把类加载阶段中的 “通过一个类的全限定名来获取描述该类的二进制字节流” 这个动态放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为类加载器。</p>
<p>&emsp;类加载器虽然只用于实现类的加载动态，但是它在 Java 程序中所起到的作用却远超过类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一个共同确立其在 Java 虚拟机中的唯一性。每一个加载器都拥有一个独立的类名称空间。<strong>比较两个类是否 “相等”，只有在这两个类是同一个加载器加载的前提下才有意义，加载器不同，两个类必定不相等</strong>。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>&emsp;从虚拟机的角度来看，只存在两种不同的类加载器：</p>
<p>1） 启动类加载器（Bootstrap Class Loader），由 C++ 语言实现，是虚拟机自身的一部分。</p>
<p>2） 其他所有类加载器，由 Java 语言实现，独立存在虚拟机外部，全部继承自抽象类 <code>java.lang.ClassLoader</code>。</p>
</li>
<li><p>从 Java 开发人员来看，则应该划分得更仔细一些。<strong>自 JDK 1. 2 以来， Java 一直保持着三层类加载器、双亲委派的类加载架构</strong>。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="启动类加载器（Bootstrap-Class-Loader"><a href="#启动类加载器（Bootstrap-Class-Loader" class="headerlink" title="启动类加载器（Bootstrap Class Loader)"></a>启动类加载器（Bootstrap Class Loader)</h3><p>&emsp;负责加载存在在 JAVA_HOME\lib 目录，或者被 -Xbootclasspath 参数所指定的路径中存放的，而且时 Java 虚拟机能够识别的（按照文件名识别，如 rt.jar, tools.jar, 名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机的内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用 null 代替即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns the class loader for the class. Some implementations may use null to represent the bootstrap class loader. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ClassLoader cl = getClassLoader0();</span><br><span class="line">	<span class="keyword">if</span> (cl == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	SecurityManager sm = System.getSecurityManager();</span><br><span class="line">	<span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">		ClassLoader ccl = ClassLoader.getCallerClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (ccl != <span class="keyword">null</span> &amp;&amp; ccl != cl &amp;&amp; !cl.isAncestor(ccl)) &#123;</span><br><span class="line">			sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展类加载器（Extension-Class-Loader"><a href="#扩展类加载器（Extension-Class-Loader" class="headerlink" title="扩展类加载器（Extension Class Loader)"></a>扩展类加载器（Extension Class Loader)</h3><p>&emsp;由  <code>sun.misc.Launcher$ExtClassLoader实现</code>，负责加载 JAVA_HOME\lib\ext 目录中，被 <code>java.ext.dirs</code> 系统变量所指定的路径中所有的类库。由于扩展类加载器是由 Java 代码来实现的，所以开发者可以直接在程序中使用扩展类加载器来加载文件。</p>
<h3 id="应用程序类加载器（Application-Class-Loader"><a href="#应用程序类加载器（Application-Class-Loader" class="headerlink" title="应用程序类加载器（Application Class Loader)"></a>应用程序类加载器（Application Class Loader)</h3><p>&emsp;由 <code>sun.misc.Launcher$AppClassLoader</code> 实现。是 <code>ClassLoader</code> 类中的 <code>getSystemClassLoader()</code> 方法的返回值，所以有些场合也称它为 “系统类加载器”。它负责加载用户类路径上所有的类库，一般情况下是程序中默认的类加载器。</p>
<p>模型图如下所示：<img src="/blog/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="类加载双亲委派模型图"></p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>&emsp;<strong>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</strong></p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>&emsp; <strong>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，<u>只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时</u>，子加载器才会尝试自己去完成加载</strong>。</p>
<blockquote>
<p>好处：</p>
<p>​        Java 中的类随着它的类加载器一起具备了一种优先级的层次关系。保证了 Java 的类型体系。对 Java 程序的稳定运作极为重要。</p>
</blockquote>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(string name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先，检查请求的类是否被加载过了</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出 ClassNotFoundException，说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 在父类加载器无法加载时，再调用本身的 findClass 方法来进行类加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><p>&emsp;<strong>先检查请求的类型是否已经被加载过，若没有则调用父类加载器的 <code>loadClass()</code>，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载器加载失败，抛出 <code>ClassNotFoundException</code>异常的话，才会调用自己的 <code>findClass()</code>方法尝试进行加载</strong>。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
