<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 启动 nginx</title>
    <url>/blog/2020/10/06/Docker%20%E5%90%AF%E5%8A%A8%20Nginx%20/</url>
    <content><![CDATA[<h1 id="Docker-启动-Nginx"><a href="#Docker-启动-Nginx" class="headerlink" title="Docker 启动 Nginx"></a>Docker 启动 Nginx</h1><p> 常规安装可以在官网上找到具体步骤,这里主要是记录 Docker 安装 Nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker 拉取 nginx 官方镜像</span></span><br><span class="line">docker pull nginx:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 nginx 容器并挂载目录映射90端口 (建议: 先启动一个容器把需要映射的文件拷贝出来,然后删除容器,重新启动一个容器把文件映射进去)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v 命令表示把外部文件挂载到容器内部,直接启动的话挂载的目录会没有文件!!!</span></span><br><span class="line">docker run -d --name nginx-container -p 90:80 \</span><br><span class="line">-v /data/nginx/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /data/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /data/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /data/nginx/log:/var/log/nginx \</span><br><span class="line">--restart=always \</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure>

<p>以上就是 docker 启动 nginx 的详细命令</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 内存结构</title>
    <url>/blog/2021/02/23/JVM%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h2><ol>
<li><p>堆</p>
<blockquote>
<ul>
<li><p>简介</p>
<p>在 Java 虚拟机中, **堆(Heap)<strong>是可供各线程共享的运行时内存区域, 该区域也几乎 Java 虚拟机所管理的最大内存区域, 该区域随着虚拟机启动而创建, <strong>所有类的实例和数组对象也几乎在这里进行分配</strong>. 这块区域管理的对象无需, 也无法显示地被销毁, <strong>自动内存管理系统(Automatic Storage Management System)</strong> 也就是常说的</strong>垃圾收集器(Garbage Collector)**会对此区域的对象进行管理. Java 堆的容量可以是固定大小的, 也可以随着程序执行的需求动态扩展, 并在不需要过多空间时自动收缩. <strong>Java 堆所使用的内存不需要保证是连续的</strong>.</p>
</li>
<li><p>异常</p>
<p><strong>如果实际所需的堆超过了自动管理内存系统所能够提供的最大容量, 那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常.</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p>方法区(永久代|元空间)</p>
<blockquote>
<ul>
<li>简介</li>
</ul>
<p> HotSpot 虚拟机设计团队把收集器的分代设计扩展到了方法区(使用永久代来实现了方法去), <strong>方法区时可供各线程共享的运行时内存区域</strong>. 它存储了每一个类的结构信息, 例如 <strong>运行时常量池(Runtime Constant Pool)</strong>, <strong>字段</strong>和<strong>方法数据</strong>, <strong>构造函数</strong>和<strong>普通方法的字节码内容</strong>, 还包括一些在<strong>类, 实例, 接口初始化时用到的特殊方法</strong>.</p>
<p> 方法去在虚拟机启动的时候创建, 是堆的逻辑组成部分, 简单虚拟机可以选择在这个区域不实现垃圾收集.方法区的容量可以是固定大小的, 也可以是动态扩展和收缩的. 在实际内存空间中可以是不连续的. </p>
<ul>
<li><p>异常</p>
</li>
<li><p><em>参考堆异常</em>*.</p>
</li>
<li><p><strong>运行时常量池(Runtime Constant Pool)</strong></p>
</li>
</ul>
<p> 运行时常量池是方法去的一部分, Class 文件中除了有类的版本, 字段, 方法, 接口等描述信息外, 还有一项信息是<strong>常量池表(Constant Pool Table)</strong>, 用于存放编译期生成的各种字面量与符号引用, 这部分内容将在类<strong>加载后存放到方法区的运行时常量池</strong>中.所以运行时常量池随着类和接口的加载被创建.<strong>异常收到方法区的限制, 创建运行时常量池的时候所需内存超过方法去所能提供的最大值, 那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常</strong>.</p>
</blockquote>
</li>
</ol>
<p><strong>堆, 方法区为线程共享区域</strong>.</p>
<ol>
<li><p>虚拟机栈</p>
<blockquote>
<ul>
<li>简介</li>
</ul>
<p> ​        Java 虚拟机栈( Java Virtual Machine Stack) 是线程私有的, 它的生命周期和线程相同.</p>
<p> 每个方法被执行时, Java 虚拟机会同步创建一个栈帧(Stack Frame) 用于存储<strong>局部变量表</strong>, <strong>操作数栈</strong>, <strong>动态连接</strong>, <strong>方法出口</strong>等信息. 每一个方法被调用直至执行完毕的过程, 就对应一个<strong>栈帧在虚拟机中从入栈到出栈的过程</strong>.</p>
<ul>
<li>异常情况</li>
</ul>
<p> ​        在 <strong>Java 虚拟机规范</strong> 中, 对这个内存区域规定了两类异常情况:</p>
<ul>
<li><ol>
<li>如果线程请求的栈<strong>深度(容量)<strong>大于虚拟机所允许的</strong>深度(最大容量)</strong>, Java虚拟机将抛出 <strong>StackOverflowError</strong> 异常</li>
</ol>
</li>
<li><ol start="2">
<li>如果Java虚拟机可以动态扩展, 当扩展时无法申请到足够的内存去完成扩展, 或者建立新的线程时没有足够的内存去创建对应的虚拟机栈, 那么Java虚拟机会抛出一个 <strong>OutOfMemoryError</strong>异常</li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p>本地方法栈(不一定要实现)</p>
<blockquote>
<ul>
<li>简介</li>
</ul>
<p> Java 虚拟机实现可能会使用到传统的栈来支持 native 方法(<strong>指使用Java以外的其它语言编写的方法</strong>)的执行, 这个栈就是本地方法栈, 如果 Java 虚拟机不支持 native 方法, 并且也不依赖传统栈的话, 可以无需支持本地方法栈. <strong>和虚拟机栈一样</strong>, 本地方法栈也是线程私有 , 其作用与虚拟机方法栈时非常相似的, 其区别只是虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务, 而本地方法栈则为虚拟机使用到的本地(native)方法服务.</p>
<ul>
<li><p>异常</p>
</li>
<li><p><em>参考虚拟机栈异常</em>*.</p>
</li>
</ul>
</blockquote>
</li>
<li><p>程序计数器(PC: Program Counter 寄存器)</p>
<blockquote>
<ul>
<li>简介</li>
</ul>
<p> 每一条 Java 虚拟机线程都有自己的 PC 寄存器, 在任意时刻, 一条 Java 虚拟机线程只会执行一个方法的代码, 这个正在被线程执行的方法称为该线程的<strong>当前方法(Current Method)</strong>. 如果这个方法不是 native 的, 那 PC 寄存器就保存 Java 虚拟机正在执行的<strong>字节码指令</strong>的地址, 如果该方法时 native 的, 那 PC 寄存器的值就是  <strong>undefined</strong>, PC 寄存器的容量至少应该能保存一个 <strong>returnAddress类型</strong>的数据或者一个与平台相关的本地指针的值.</p>
</blockquote>
</li>
</ol>
<p><strong>虚拟机栈, 本地方法栈, 程序计数器为线程私有区域</strong>.</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java null 比较问题</title>
    <url>/blog/2020/09/20/Java%20null%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Java-null-比较问题"><a href="#Java-null-比较问题" class="headerlink" title="Java null 比较问题"></a>Java null 比较问题</h1><ol>
<li>null 不能与数值进行比较</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// null 直接和数据比较， 编译报错</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">null</span> == <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值变量，然后再比较，会抛出 NullPointerException</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">Integer b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = a == b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因： == 比较是直接比较内存地址大小，<code>Integer b = null</code>中 b 并未指向任何地址，所以程序会抛出 <code>NullPointerException</code> </p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 类加载器</title>
    <url>/blog/2021/03/02/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="JVM-类加载器"><a href="#JVM-类加载器" class="headerlink" title="JVM 类加载器"></a>JVM 类加载器</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;Java 虚拟机设计团队有意把类加载阶段中的 “通过一个类的全限定名来获取描述该类的二进制字节流” 这个动态放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为类加载器。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h3><p>&emsp;类加载器虽然只用于实现类的加载动态，但是它在 Java 程序中所起到的作用却远超过类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一个共同确立其在 Java 虚拟机中的唯一性。每一个加载器都拥有一个独立的类名称空间。<strong>比较两个类是否 “相等”，只有在这两个类是同一个加载器加载的前提下才有意义，加载器不同，两个类必定不相等</strong>。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h3><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><ul>
<li><p>&emsp;从虚拟机的角度来看，只存在两种不同的类加载器：</p>
<p>1） 启动类加载器（Bootstrap Class Loader），由 C++ 语言实现，是虚拟机自身的一部分。</p>
<p>2） 其他所有类加载器，由 Java 语言实现，独立存在虚拟机外部，全部继承自抽象类 <code>java.lang.ClassLoader</code>。</p>
</li>
<li><p>从 Java 开发人员来看，则应该划分得更仔细一些。<strong>自 JDK 1. 2 以来， Java 一直保持着三层类加载器、双亲委派的类加载架构</strong>。</p>
</li>
</ul>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><ul>
<li><p>启动类加载器（Bootstrap Class Loader)</p>
<p>&emsp;负责加载存在在 JAVA_HOME\lib 目录，或者被 -Xbootclasspath 参数所指定的路径中存放的，而且时 Java 虚拟机能够识别的（按照文件名识别，如 rt.jar, tools.jar, 名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机的内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用 null 代替即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns the class loader for the class. Some implementations may use null to represent the bootstrap class loader. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ClassLoader cl = getClassLoader0();</span><br><span class="line">	<span class="keyword">if</span> (cl == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	SecurityManager sm = System.getSecurityManager();</span><br><span class="line">	<span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">		ClassLoader ccl = ClassLoader.getCallerClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (ccl != <span class="keyword">null</span> &amp;&amp; ccl != cl &amp;&amp; !cl.isAncestor(ccl)) &#123;</span><br><span class="line">			sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩展类加载器（Extension Class Loader)</p>
<p>&emsp;由 <code>sun.misc.Launcher$ExtClassLoader实现</code>，负责加载 JAVA_HOME\lib\ext 目录中，被 <code>java.ext.dirs</code> 系统变量所指定的路径中所有的类库。由于扩展类加载器是由 Java 代码来实现的，所以开发者可以直接在程序中使用扩展类加载器来加载文件。</p>
</li>
<li><p>应用程序类加载器（Application Class Loader)</p>
<p>&emsp;由<code>sun.misc.Launcher$AppClassLoader</code>实现。是 <code>ClassLoader</code> 类中的<code>getSystemClassLoader()</code>方法的返回值，所以有些场合也称它为 “系统类加载器”。它负责加载用户类路径上所有的类库，一般情况下是程序中默认的类加载器。</p>
</li>
</ul>
<p>模型图如下所示：<img src="/blog/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="类加载双亲委派模型图"></p>
<p>&emsp;<strong>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</strong></p>
<h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4><p>&emsp; <strong>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，<u>只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时</u>，子加载器才会尝试自己去完成加载</strong>。</p>
<blockquote>
<p>好处：</p>
<p>​        Java 中的类随着它的类加载器一起具备了一种优先级的层次关系。保证了 Java 的类型体系。对 Java 程序的稳定运作极为重要。</p>
</blockquote>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(string name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先，检查请求的类是否被加载过了</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出 ClassNotFoundException，说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 在父类加载器无法加载时，再调用本身的 findClass 方法来进行类加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><p>&emsp;<strong>先检查请求的类型是否已经被加载过，若没有则调用父类加载器的 <code>loadClass()</code>，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载器加载失败，抛出 <code>ClassNotFoundException</code>异常的话，才会调用自己的 <code>findClass()</code>方法尝试进行加载</strong>。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 类加载过程</title>
    <url>/blog/2021/03/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="JVM-类加载过程"><a href="#JVM-类加载过程" class="headerlink" title="JVM 类加载过程"></a>JVM 类加载过程</h1><p>&emsp;<strong>类加载过程分为7个阶段。加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析统称为连接</strong>。</p>
<ol>
<li><p><strong>加载</strong></p>
<blockquote>
<p>  &emsp;加载是整个类加载过程中的第一个阶段。在加载阶段， Java虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名类获取此类的二进制字节流（不限制来源，开发人员可控性最强）。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区对这个类各种数据的访问入口</li>
</ul>
<p>&emsp;《Java》虚拟机对这三点要求不是特别具体，留给虚拟机的灵活实现特别大。值得注意的一点是：数组类不通过类加载器创建，它是由 Java 虚拟机直接在内存中动态构造出来的。而加载阶段和连接阶段（验证、准备、解析）可能是交叉进行的。但开始时间任然保持着固定的先后顺序。</p>
</blockquote>
</li>
<li><p><strong>验证</strong></p>
<blockquote>
<p>&emsp;验证是连接阶段的第一步，目的是确保 Class 文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求。确保代码运行时不会危害虚拟机自身的安全。所以验证字节码是 Java 虚拟机保护自身的一项必要措施。这一阶段的工作量在虚拟机的类加载过程中占了相当大的比重。整体上看，验证分为四个阶段的检验动作：</p>
<ol>
<li><p><strong>文件格式验证</strong></p>
</li>
<li><p><strong>元数据验证</strong></p>
</li>
<li><p><strong>字节码验证</strong></p>
</li>
</ol>
<p>  此阶段最复杂，需通过数据流和控制流分析，确保程序语义是合法的，符合逻辑的。</p>
<ol start="4">
<li><strong>符号引用验证</strong></li>
</ol>
</blockquote>
</li>
<li><p><strong>准备</strong></p>
<blockquote>
<p>&emsp;准备阶段是正式为类中定义的变量(即静态变量)分配内存并设置类变量初始值的阶段。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value =  <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;其中变量 value 在准备结果过后的初始值为 0 而不是 123，因为这时尚未开始执行任何 Java 方法，而 value 赋值为 123 的 putstatic 指令时程序被编译后，存放在类构造器 &lt;clinit&gt;() 方法之中，所以把 value 赋值为 123 的动作要到类的初始化阶段才会被执行。</p>
<p>&emsp;如果类字段的字段属性表中存在 ConstantValue 属性，那么准备阶段变量值就会被初始化为 ConstantValue 属性所指定的值，例子中 num 就会被虚拟机赋值为 123。</p>
<p>&emsp;<strong>注意</strong>：在准备阶段，虚拟机只会为类变量进行内存分配，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p>
</blockquote>
</li>
<li><p>解析</p>
<blockquote>
<p>&emsp;解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li><p>符号引用：</p>
<p>&emsp;符号引用是以一组符号来描述所引用的目标，符号可以是任意的字面量，只要能够无歧义的定位到目标即可。符号引用的字面量形式明确定义在 《Java虚拟机规范》的 Class 文件格式中。所以与虚拟机实现的内存布局无关。<strong>符号引用并不一定是已经加载到虚拟机内存当中的内容</strong>。</p>
</li>
<li><p>直接引用：</p>
<p>&emsp;直接引用就是可以直接执行目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实力上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那么引用的目标必定已经在虚拟机的内存中存在</strong>。</p>
</li>
</ul>
<p>《Java虚拟机规范》并未规定解析阶段发生的具体时间。只要求了在执行 newarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc_w、ldc2_w、multianewarray、new、putfield、putstatic 这17个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。</p>
<p>&emsp;对同一个符号引用进行多次解析请求是很常见的，所以除了 invokedynamic 指令以外，虚拟机实现可以对第一次解析的结果进行缓存。</p>
<p>&emsp;<strong>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行</strong>。</p>
</blockquote>
</li>
<li><p><strong>初始化</strong></p>
<blockquote>
<p>&emsp;类的初始化阶段是类加载过程中最后一个阶段。直到初始化阶段，Java 虚拟机才真正开始执行类中 Java 程序代码, 将主导权移交给应用程序。</p>
<p>&emsp;<strong>初始化阶段就是执行类构造器 <code>&lt;clinit&gt;() </code>方法的过程, <code>&lt;clinit&gt;()</code>并不是程序员在 Java 代码中编写的方法，它是 Javac 编译器的自动生成物。</strong></p>
<p><code>&lt;clinit&gt;()</code>方法：</p>
<ul>
<li><p>&emsp;是由编译器自动收集类中所有类变量的赋值动态和静态语句块中的语句合并产生的，收集顺序由语句在源文件中出现的顺序决定，静态语句块中只能访问定义在静态语句块之前的变量，定义在之后的变量，前面的静态语句块可以赋值，但是不能访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i  = <span class="number">0</span>;  <span class="comment">// 给变量赋值可以正常编译通过 </span></span><br><span class="line">        System.out.print(i); <span class="comment">// 编译报错，提示 “非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>&emsp;与类的构造函数（虚拟机中实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显示调用父类构造器，Java 虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。**因此在 Java 虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是 <code>java.lang.Object</code>**。</p>
</li>
<li><p>&emsp;对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>&emsp;接口中不能使用静态语句块，但仍然有变量初始化赋值操作，所以接口也会生成<code>&lt;clinit&gt;()</code>方法。但接口和类不同，接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>Java 虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其它线程都需要阻塞等待，直到活动线程执行完毕<code>&lt;clinit&gt;()</code>方法。如果在一个类的<code>&lt;clinit&gt;()</code>方法方法中有耗时很长的操作，那就可能造成多个进程阻塞。这种阻塞往往是很隐蔽的。当其中一个线程执行完<code>&lt;clinit&gt;()</code>方法后，其它线程唤醒后不会再次进入<code>&lt;clinit&gt;()</code>方法。<strong>在同一个类加载器下，一个类型只会被初始化一次</strong>。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>使用</strong></p>
<blockquote>
<p>略。</p>
</blockquote>
</li>
<li><p><strong>卸载</strong></p>
<blockquote>
<p>略。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 六种类初始化条件</title>
    <url>/blog/2021/02/24/%E7%B1%BB%E7%AB%8B%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="六种类初始化条件"><a href="#六种类初始化条件" class="headerlink" title="六种类初始化条件"></a>六种类初始化条件</h1><blockquote>
<p>《Java虚拟机规范》严格规定了有且只有六种情况必须对类进行 “初始化”（加载、验证、准备需在此之前开始）。</p>
</blockquote>
<ol>
<li><p>遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时。生成这四条指令的 Java 场景有：</p>
<blockquote>
<ul>
<li>使用 new 关键字实例化对象的时候</li>
<li>读取或设置一个静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
</blockquote>
</li>
<li><p>使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则会触发其初始化</p>
</li>
<li><p>初始化类时，发现其父类还未初始化，则需要先对其父类进行初始化</p>
</li>
<li><p>虚拟机启动时，用户需指定一个执行的主类（包含 main() 方法），虚拟机会先初始化这个类</p>
</li>
<li><p>如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、 REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需先触发其初始化</p>
</li>
<li><p>当一个接口定义了默认方法（被 default 关键字修饰的方法）时，如果有这个接口的实现类发生了初始化，那么该接口会在其之前被初始化</p>
</li>
</ol>
<p><strong>《Java虚拟机规范》中使用了一个非常强烈的限定语<code>有且只有</code>，这六种场景中的行为称为对一个类型的主动引用。除此之外，所有引用类型的方式都不会触发其初始化，称为被动引用。</strong></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中线程创建的几种方式</title>
    <url>/blog/2020/10/05/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Java-线程创建的几种方式"><a href="#Java-线程创建的几种方式" class="headerlink" title="Java 线程创建的几种方式"></a>Java 线程创建的几种方式</h1><p><code>Java</code> 中线程的创建一般包含4种方式：</p>
<ol>
<li><p>继承 <code>Thread</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Mythread 实例, 调用 start 方法启用一个新线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Mythread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现 <code>Runnable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pubic <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Thread 实例,传入 MyRunnable 实列, 调用 start 方法启用一个新线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现 <code>Callable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sting <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Callable callable = <span class="keyword">new</span> MyCallable;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        <span class="comment">// 创建一个 Thread 实例, 启用一个新线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// Future#get 方法会阻塞,一直等到线程运行完成, 会得到一个返回值</span></span><br><span class="line">        <span class="comment">// str = &#x27;hello world&#x27;</span></span><br><span class="line">        String str = futureTask.get();</span><br><span class="line">        <span class="comment">// 获取结果, 如果没结果可用, 则阻塞到指定时间为止,到时还未产生结果则抛出 TimeOutException 异常</span></span><br><span class="line">        String str1 = futureTask.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用线程池创建(推荐)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认参数：</span></span><br><span class="line"><span class="comment">     * 1） corePoolSize： 核心线程数</span></span><br><span class="line"><span class="comment">     * 2） maximumPoolSize: 最大线程数  0x7fffffff</span></span><br><span class="line"><span class="comment">     * 3)  keepAliveTime: 60L 存活时间</span></span><br><span class="line"><span class="comment">     * 4） unit： TimeUnit.SECONDS， 线程空闲大于指定存活时间， 就会释放线程</span></span><br><span class="line"><span class="comment">     * 5)  workQueue:  new SynchronousQueue&lt;Runnable&gt;() 阻塞队列</span></span><br><span class="line"><span class="comment">     * 6) threadFactory： 线程的创建工厂</span></span><br><span class="line"><span class="comment">     * 7） RejectedExecutionHandler : 如果队列满了，按照指定拒绝策略拒绝执行任务</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 工作顺序:</span></span><br><span class="line"><span class="comment">     * 1. 线程池创建， 准备好 core 线程数量的核心线程，准备接受任务</span></span><br><span class="line"><span class="comment">     * 2. core 满了， 就将再进来的任务放入到阻塞队列中，空闲的 core 就会自己去阻塞队列获取任务执行</span></span><br><span class="line"><span class="comment">     * 3. 阻塞队列满了， 就直接新开线程执行， 最大只能开到 max 指定的数量</span></span><br><span class="line"><span class="comment">     * 4. max 满了就要用 RejectedExecutionHandler 策略拒绝任务</span></span><br><span class="line"><span class="comment">     * 5. max 都执行完， 有很多空闲， 指定的时间 keepAliveTime 以后， 就会释放 max-core 这些线程</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 问题： 一个线程池 core 7、max 20、 queue 50， 100 并发进来是怎么分配的？</span></span><br><span class="line"><span class="comment">     * 答： 7个线程会获得立即执行， 50 个请求会进入到阻塞队列，队列满了会再开 13 个线程进行执行，剩下的就使用拒绝策略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TheadPoolExecutor executor = <span class="keyword">new</span> ThreadExecutor(<span class="number">5</span>, <span class="number">20</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">256</span>), 		       Excutors.DefaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前三种创建线程的方式其实都是一种, 即新建一个 <code>Thread</code> 实例, 调用  <code>start</code> 方法来创建一个线程, 这种方式也就是显示创建线程. 一般开发中不推荐这种方式, 开发中常用的是创建线程池的方式, 以线程池的方式创建线程有一下几个好处:</p>
<ol>
<li><p>降低资源消耗： 通过重复利用已经创建好的线程降低线程的创建和销毁带来的损耗</p>
</li>
<li><p>提高响应速度： 当线程池中的线程数没超过线程池的最大上限时，会有线程等待分配任务， 当任务来时无需创建新的线程就能运行</p>
</li>
<li><p>提高线程的可管理性： 线程池会优化处理，减少创建销毁线程带来的影响， 无限创建销毁线程会大量损耗系统资源， 降低系统稳定行，使用线程池可统一分配， 线程池不用的时候可以关闭</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
